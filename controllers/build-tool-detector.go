/*

Package controllers is autogenerated
and containing scaffold outputs
as well as manually created sub-packages
and files.

*/
package controllers

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/goadesign/goa"
	"github.com/tinakurian/build-tool-detector/app"
	errs "github.com/tinakurian/build-tool-detector/controllers/error"
	"github.com/tinakurian/build-tool-detector/domain/repository"
	"github.com/tinakurian/build-tool-detector/domain/repository/github"
	"github.com/tinakurian/build-tool-detector/domain/types"
	"github.com/tinakurian/build-tool-detector/log"
)

var (
	// ErrFailedJSONMarshal unable to marshal json.
	ErrFailedJSONMarshal = errors.New("unable to marshal json")

	// ErrFailedPropagate unable to propagate error
	ErrFailedPropagate = errors.New("unable to propagate error")
)

const (
	errorz                      = "error"
	contentType                 = "Content-Type"
	applicationJSON             = "application/json"
	buildToolDetectorController = "BuildToolDetectorController"
)

// BuildToolDetectorController implements the build-tool-detector resource.
type BuildToolDetectorController struct {
	*goa.Controller
	ghClientID     string
	ghClientSecret string
}

// NewBuildToolDetectorController creates a build-tool-detector controller.
func NewBuildToolDetectorController(service *goa.Service, ghClientID string, ghClientSecret string) *BuildToolDetectorController {
	return &BuildToolDetectorController{Controller: service.NewController(buildToolDetectorController), ghClientID: ghClientID, ghClientSecret: ghClientSecret}
}

// Show runs the show action.
func (c *BuildToolDetectorController) Show(ctx *app.ShowBuildToolDetectorContext) error {
	rawURL := ctx.URL
	// TODO Here's what I think we can do
	// - create a service called BuildToolDetector which will take repository service as a collaborator
	// - exposes simple method Detect (need to figure out what kind of params are really needed) which returns BuildType
	//   - the idea is that RepositoryService interacts on GH API level
	//   - build-related logic will sit in this new service
	//   - so we don't mix two layers of abstraction in one place
	// In here simple orchestration only should reside
	repositoryService, err := repository.CreateService(rawURL, ctx.Branch, c.ghClientID, c.ghClientSecret)
	ctx.ResponseWriter.Header().Set(contentType, applicationJSON)
	if err != nil {
		return handleError(ctx, err)
	}

	buildToolType, err := repositoryService.DetectBuildTool(ctx.Context)
	if err != nil {
		return handleError(ctx, err)
	}

	buildTool := types.Unknown()
	if types.MavenBuild == *buildToolType {
		buildTool = types.Maven()
	}
	return ctx.OK(buildTool)

}

func handleError(ctx *app.ShowBuildToolDetectorContext, err error) error {
	switch err.Error() {
	case github.ErrInvalidPath.Error():
		httpError := errs.ErrBadRequest(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.BadRequest()
	case github.ErrResourceNotFound.Error():
		httpError := errs.ErrNotFoundError(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.NotFound()
	case github.ErrUnsupportedService.Error(),
		github.ErrUnsupportedGithubURL.Error():
		httpError := errs.ErrInternalServerError(err)
		writerErr := formatResponse(ctx, httpError)
		if writerErr != nil {
			return writerErr
		}
		return ctx.InternalServerError()
	case github.ErrFailedContentRetrieval.Error():
		buildTool := types.Unknown()
		return ctx.OK(buildTool)
	default:
		return ctx.InternalServerError()
	}
}

func formatResponse(ctx *app.ShowBuildToolDetectorContext, httpTypeError *errs.HTTPTypeError) error {
	ctx.WriteHeader(httpTypeError.StatusCode)
	jsonHTTPTypeError, err := json.Marshal(httpTypeError)
	if err != nil {
		log.Logger().WithError(err).WithField(errorz, httpTypeError).Errorf(ErrFailedJSONMarshal.Error())
		return ctx.InternalServerError()
	}

	if _, err := fmt.Fprint(ctx.ResponseWriter, string(jsonHTTPTypeError)); err != nil {
		log.Logger().WithError(err).WithField(errorz, jsonHTTPTypeError).Errorf(ErrFailedPropagate.Error())
		return ctx.InternalServerError()
	}
	return nil
}
